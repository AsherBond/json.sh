<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>json.sh</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>json.sh</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><p><code>json.sh</code>, a pure-shell JSON parser.</p>

</td><td class=code><div class=highlight><pre>

<span class="nb">set</span> -e

</pre></div></td></tr><tr><td class=docs>

<p>File descriptor 3 is commandeered for debug output, which may end up being
forwarded to standard error.</p>

</td><td class=code><div class=highlight><pre>
<span class="o">[</span> -z <span class="s2">&quot;$JSON_DEBUG&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">exec </span>3&gt;/dev/null <span class="o">||</span> <span class="nb">exec </span>3&gt;&amp;2

</pre></div></td></tr><tr><td class=docs>

<p>File descriptor 4 is commandeered for use as a sink for literal and
variable output of (inverted) sections that are not destined for standard
output because their condition is not met.</p>

</td><td class=code><div class=highlight><pre>
<span class="nb">exec </span>4&gt;/dev/null

</pre></div></td></tr><tr><td class=docs>

<p>Consume standard input one character at a time to parse JSON.</p>

</td><td class=code><div class=highlight><pre>
json<span class="o">()</span> <span class="o">{</span>

</pre></div></td></tr><tr><td class=docs>

<p>Initialize the file descriptor to be used to emit characters.  At
times this value will be 4 to send output to <code>/dev/null</code>.</p>

</td><td class=code><div class=highlight><pre>
	<span class="nv">_J_FD</span><span class="o">=</span>1

</pre></div></td></tr><tr><td class=docs>

<p>Initialize storage for the "pathname", the concatenation of all
the keys in the tree at any point in time, the current state of
the machine, and the state to which the machine returns after
completing a key or value.</p>

</td><td class=code><div class=highlight><pre>
	<span class="nv">_J_PATHNAME</span><span class="o">=</span><span class="s2">&quot;/&quot;</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;whitespace&quot;</span> <span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;whitespace&quot;</span>

</pre></div></td></tr><tr><td class=docs>

<p>IFS must only contain '\n' so as to be able to read space and tab
characters from standard input one-at-a-time.  The easiest way to
convince it to actually contain the correct byte, and only the
correct byte, is to use a single-quoted literal newline.</p>

</td><td class=code><div class=highlight><pre>
	<span class="nv">IFS</span><span class="o">=</span><span class="s1">&#39;</span>
<span class="s1">&#39;</span>

</pre></div></td></tr><tr><td class=docs>

<p>Consuming standard input one character at a time is quite a feat
within the confines of POSIX shell.  Bash's <code>read</code> builtin has
<code>-n</code> for limiting the number of characters consumed.  Here it is
faked using <code>sed</code>(1) to place each character on its own line.
The subtlety is that real newline characters are chomped so they
must be indirectly detected by checking for zero-length
characters, which is done as the character is emitted.</p>

</td><td class=code><div class=highlight><pre>
	sed -r <span class="s2">&quot;</span>
<span class="s2">		s/./&amp;\\n/g</span>
<span class="s2">		s/\\\\/\\\\\\\\/g</span>
<span class="s2">	&quot;</span> | _json

</pre></div></td></tr><tr><td class=docs>

<p>TODO Replace the original value of IFS.  Be careful if it's unset.</p>

</td><td class=code><div class=highlight><pre>

<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Consume the one-character-per-line stream from <code>sed</code> via a state machine.
This function will be called recursively in subshell environments to
isolate values from their containing scope.</p>

<p>The <code>read</code> builtin consumes one line at a time but by now each line
contains only a single character.</p>

</td><td class=code><div class=highlight><pre>
_json<span class="o">()</span> <span class="o">{</span>
	<span class="k">while </span><span class="nb">read </span>_J_C
	<span class="k">do</span>
<span class="k">		</span>_json_char
		<span class="nv">_J_PREV_C</span><span class="o">=</span><span class="s2">&quot;$_J_C&quot;</span>
	<span class="k">done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Consume a single character as stored in <code>_J_C</code>.  This function is broken
out from <code>_json</code> so it may be called to reconsume a character as is
necessary following the end of any number since numbers do not have a
well-known ending in the grammar.</p>

<p>The state machine implemented here follows very naturally from the
diagrams of the JSON grammar on <a href="http://json.org">http://json.org</a>.</p>

</td><td class=code><div class=highlight><pre>
_json_char<span class="o">()</span> <span class="o">{</span>
	<span class="nb">echo</span> <span class="s2">&quot; _J_C: $_J_C (${#_J_C}), _J_STATE: $_J_STATE&quot;</span> &gt;&amp;3
	<span class="k">case</span> <span class="s2">&quot;$_J_STATE&quot;</span> in

</pre></div></td></tr><tr><td class=docs>

<p>The machine starts in the "whitespace" state and learns
from leading characters what state to enter next.  JSON's
grammar doesn't contain any tokens that are ambiguous in
their first character so the parser's job is relatively
easier.</p>

<p>Further whitespace characters are consumed and ignored.</p>

<p>Arrays are unique in that their parsing rules are a strict
superset of the rules in open whitespace.  When an opening
bracket is encountered, the remainder of the array is
parsed in a subshell which goes around again when a comma
is encountered and exits back to the containing scope when
the closing bracket is encountered.</p>

<p>Objects are not parsed as a superset of open whitespace but
they are parsed in a subshell to protect the containing scope.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;array-0&quot;</span>|<span class="s2">&quot;array-even&quot;</span>|<span class="s2">&quot;array-odd&quot;</span>|<span class="s2">&quot;whitespace&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_STATE&quot;</span> in
				<span class="s2">&quot;array-0&quot;</span><span class="o">)</span>
					<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
						<span class="s2">&quot;]&quot;</span><span class="o">)</span> <span class="nb">exit</span>;;
					<span class="k">esac</span>;;
				<span class="s2">&quot;array-even&quot;</span><span class="o">)</span>
					<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
						<span class="s2">&quot;,&quot;</span><span class="o">)</span>
							<span class="nv">_J_DIRNAME</span><span class="o">=</span><span class="s2">&quot;$(dirname &quot;</span><span class="nv">$_J_PATHNAME</span><span class="s2">&quot;)&quot;</span>
								<span class="o">[</span> <span class="s2">&quot;$_J_DIRNAME&quot;</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nv">_J_DIRNAME</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
							<span class="nv">_J_BASENAME</span><span class="o">=</span><span class="s2">&quot;$(basename &quot;</span><span class="nv">$_J_PATHNAME</span><span class="s2">&quot;)&quot;</span>
							<span class="nv">_J_BASENAME</span><span class="o">=</span><span class="s2">&quot;$(($_J_BASENAME + 1))&quot;</span>
							<span class="nv">_J_PATHNAME</span><span class="o">=</span><span class="s2">&quot;$_J_DIRNAME/$_J_BASENAME&quot;</span>
							<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;array-odd&quot;</span>
							<span class="k">continue</span>;;
						<span class="s2">&quot;]&quot;</span><span class="o">)</span> <span class="nb">exit</span>;;
					<span class="k">esac</span>;;
			<span class="k">esac</span>
<span class="k">			case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;\&quot;&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;string&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;&quot;</span>;;
				<span class="s2">&quot;-&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-negative&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_C&quot;</span>;;
				0<span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-leading-zero&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_C&quot;</span>;;
				<span class="o">[</span>1-9<span class="o">])</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-leading-nonzero&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_C&quot;</span>;;
				<span class="s2">&quot;[&quot;</span><span class="o">)</span>
					<span class="o">(</span>
						<span class="o">[</span> <span class="s2">&quot;$_J_PATHNAME&quot;</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nv">_J_PATHNAME</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
						<span class="nv">_J_PATHNAME</span><span class="o">=</span><span class="s2">&quot;$_J_PATHNAME/0&quot;</span>
						<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;array-0&quot;</span> <span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;array-even&quot;</span>
						_json
					<span class="o">)</span>
					<span class="nb">exit</span>;;
				<span class="s2">&quot;f&quot;</span>|<span class="s2">&quot;t&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_C&quot;</span>;;
				<span class="s2">&quot;n&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;null&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_C&quot;</span>;;
				<span class="s2">&quot;{&quot;</span><span class="o">)</span>
					<span class="o">(</span>
						<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;object-0&quot;</span> <span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;object-even&quot;</span>
						_json
					<span class="o">)</span>
					<span class="nb">exit</span>;;
				<span class="s2">&quot;	&quot;</span>|<span class="s2">&quot;&quot;</span>|<span class="s2">&quot; &quot;</span><span class="o">)</span> ;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Boolean values are multicharacter literals but they're unique
from their first character.  This means the eventual value is
already known when the "boolean" state is entered so we can
raise syntax errors as soon as the input goes south.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;boolean&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_V$_J_C&quot;</span> in
				<span class="s2">&quot;f&quot;</span>|<span class="s2">&quot;fa&quot;</span>|<span class="s2">&quot;fal&quot;</span>|<span class="s2">&quot;fals&quot;</span>|<span class="s2">&quot;t&quot;</span>|<span class="s2">&quot;tr&quot;</span>|<span class="s2">&quot;tru&quot;</span><span class="o">)</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;false&quot;</span>|<span class="s2">&quot;true&quot;</span><span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME boolean $_J_V$_J_C&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME boolean $_J_V$_J_C&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Object values are relatively more complex than array values.
They begin in the "object-0" state, which is almost but not
quite a subset of the "whitespace" state for strings.  When
a string is encountered it is parsed as usual but the parser
is set to return to the "object-value" state afterward.</p>

<p>As in the "whitespace" state, extra whitespace characters
are consumed and ignored.</p>

<p>The parser will return to this "object" state later to
either consume a comma and go around again or exit the
subshell in which this object has been parsed.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;object-0&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;\&quot;&quot;</span><span class="o">)</span>
					<span class="nv">_J_FD</span><span class="o">=</span>4
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;string&quot;</span>
					<span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;object-value&quot;</span>
					<span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;&quot;</span>;;
				<span class="s2">&quot;}&quot;</span><span class="o">)</span> <span class="nb">exit</span>;;
				<span class="s2">&quot;	&quot;</span>|<span class="s2">&quot;&quot;</span>|<span class="s2">&quot; &quot;</span><span class="o">)</span> ;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>"object-even" is like "object-0" but additionally commas are
consumed to enforce the another key/value pair is coming.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;object-even&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;\&quot;&quot;</span><span class="o">)</span>
					<span class="nv">_J_FD</span><span class="o">=</span>4
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;string&quot;</span>
					<span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;object-value&quot;</span>
					<span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;&quot;</span>;;
				<span class="s2">&quot;,&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;object-odd&quot;</span>;;
				<span class="s2">&quot;}&quot;</span><span class="o">)</span> <span class="nb">exit</span>;;
				<span class="s2">&quot;	&quot;</span>|<span class="s2">&quot;&quot;</span>|<span class="s2">&quot; &quot;</span><span class="o">)</span> ;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Object values have to return from whence they came.  They use
the "object-exit" state to signal the last character consumed
to the containing scope.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;object-exit&quot;</span><span class="o">)</span> <span class="c">#exit;;</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;,&quot;</span><span class="o">)</span> <span class="nb">exit </span>101;;
				<span class="s2">&quot;}&quot;</span><span class="o">)</span> <span class="nb">exit </span>102;;
				*<span class="o">)</span> <span class="nb">exit </span>0;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>"object-even" is like "object-0" but cannot consume a closing
brace because it has just consumed a comma.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;object-odd&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;\&quot;&quot;</span><span class="o">)</span>
					<span class="nv">_J_FD</span><span class="o">=</span>4
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;string&quot;</span>
					<span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;object-value&quot;</span>
					<span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;&quot;</span>;;
				<span class="s2">&quot;	&quot;</span>|<span class="s2">&quot;&quot;</span>|<span class="s2">&quot; &quot;</span><span class="o">)</span> ;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>After a string key has been consumed, the state machine
progresses here where a colon and a value are parsed.  The
value is parsed in a subshell so the pathname can have the
key appended to it before the parser continues.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;object-value&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;:&quot;</span><span class="o">)</span>
					<span class="nv">_J_FD</span><span class="o">=</span>1
					<span class="o">(</span>
						<span class="o">[</span> <span class="s2">&quot;$_J_PATHNAME&quot;</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nv">_J_PATHNAME</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
						<span class="nv">_J_PATHNAME</span><span class="o">=</span><span class="s2">&quot;$_J_PATHNAME/$_J_V&quot;</span>
						<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;whitespace&quot;</span>
						<span class="nv">_J_STATE_DEFAULT</span><span class="o">=</span><span class="s2">&quot;object-exit&quot;</span>
						_json
					<span class="o">)</span> <span class="o">||</span> <span class="k">case</span> <span class="s2">&quot;$?&quot;</span> in
						101<span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;object-even&quot;</span> <span class="nv">_J_C</span><span class="o">=</span><span class="s2">&quot;,&quot;</span> _json_char;;
						102<span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;object-even&quot;</span> <span class="nv">_J_C</span><span class="o">=</span><span class="s2">&quot;}&quot;</span> _json_char;;
					<span class="k">esac</span>
<span class="k">					</span><span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;object-even&quot;</span>;;
				<span class="s2">&quot;	&quot;</span>|<span class="s2">&quot;&quot;</span>|<span class="s2">&quot; &quot;</span><span class="o">)</span> ;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Null values work exactly like boolean values.  See above.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;null&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_V$_J_C&quot;</span> in
				<span class="s2">&quot;n&quot;</span>|<span class="s2">&quot;nu&quot;</span>|<span class="s2">&quot;nul&quot;</span><span class="o">)</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;null&quot;</span><span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME null null&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME null $_J_V$_J_C&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Numbers that encounter a '.' become floating point and may
continue consuming digits forever or may become
scientific-notation.  Any other character sends the parser
back to its default state.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;number-float&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="o">[</span>0-9<span class="o">])</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;E&quot;</span>|<span class="s2">&quot;e&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-sci&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				*<span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME number $_J_V&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>
					_json_char;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>This is an entrypoint into parsing a number, used when
the first digit consumed is non-zero.  From here, a number
may continue on a positive integer, become a floating-point
number by consuming a '.', or become scientific-notation by
consuming an 'E' or 'e'.  Any other character sends the
parser back to its default state.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;number-leading-nonzero&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;.&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-float&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="o">[</span>0-9<span class="o">])</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;E&quot;</span>|<span class="s2">&quot;e&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-sci&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				*<span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME number $_J_V&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>
					_json_char;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>This is an entrypoint into parsing a number, used when
the first digit consumed is zero.  From here, a number
may remain zero, become a floating-point number by
consuming a '.', or become scientific-notation by consuming
an 'E' or 'e'.  Any other character sends the parser back
to its default state.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;number-leading-zero&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;.&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-float&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="o">[</span>0-9<span class="o">])</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME number $_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;E&quot;</span>|<span class="s2">&quot;e&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-sci&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				*<span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME number $_J_V&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>
					_json_char;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>This is an entrypoint into parsing a number, used when
the first character consumed is a '-'.  From here, a number
may progress to the "number-leading-nonzero" or
"number-leading-zero" states.  Any other character sends
the parser back to its default state.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;number-negative&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				0<span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-leading-zero&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="o">[</span>1-9<span class="o">])</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-leading-nonzero&quot;</span>
					<span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				*<span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME number $_J_V&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>
					_json_char;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Numbers that encounter an 'E' or 'e' become
scientific-notation and consume digits, optionally prefixed
by a '+' or '-', forever.  The actual consumption is
delegated to the "number-sci-neg" and "number-sci-pos"
states.  Any other character immediately following the 'E'
or 'e' is a syntax error.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;number-sci&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="s2">&quot;+&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-sci-pos&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;-&quot;</span><span class="o">)</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-sci-neg&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="o">[</span>0-9<span class="o">])</span> <span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;number-sci-pos&quot;</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				*<span class="o">)</span> _json_die <span class="s2">&quot;syntax: $_J_PATHNAME number $_J_V$_J_C&quot;</span>;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Once in these states, numbers may consume digits forever.
Any other character sends the parser back to its default
state.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;number-sci-neg&quot;</span>|<span class="s2">&quot;number-sci-pos&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_C&quot;</span> in
				<span class="o">[</span>0-9<span class="o">])</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				*<span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME number $_J_V&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>
					_json_char;;
			<span class="k">esac</span>;;

</pre></div></td></tr><tr><td class=docs>

<p>Strings aren't as easy as they look.  JSON supports several
escape sequences that require the state machine to keep a
history of its input.  Basic backslash/newline/etc. escapes
are simple because they only require one character of
history.  Unicode codepoint escapes require more.  The
strategy there is to add states to the machine.</p>

<p>TODO It'd be nice to decode all escape sequences, including
Unicode codepoints but that would definitely ruin the
line-oriented thing we've got goin' on.</p>

</td><td class=code><div class=highlight><pre>
		<span class="s2">&quot;string&quot;</span><span class="o">)</span>
			<span class="k">case</span> <span class="s2">&quot;$_J_PREV_C$_J_C&quot;</span> in
				<span class="s2">&quot;\\\&quot;&quot;</span>|<span class="s2">&quot;\\/&quot;</span>|<span class="s2">&quot;\\\\&quot;</span><span class="o">)</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
				<span class="s2">&quot;\\b&quot;</span>|<span class="s2">&quot;\\f&quot;</span>|<span class="s2">&quot;\\n&quot;</span>|<span class="s2">&quot;\\r&quot;</span><span class="o">)</span>  <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V\\\\$_J_C&quot;</span>;;
				<span class="s2">&quot;\\u&quot;</span><span class="o">)</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V\\\\$_J_C&quot;</span>;;
				*<span class="s2">&quot;\&quot;&quot;</span><span class="o">)</span>
					<span class="nv">_J_STATE</span><span class="o">=</span><span class="s2">&quot;$_J_STATE_DEFAULT&quot;</span>
					<span class="nb">echo</span> <span class="s2">&quot;$_J_PATHNAME string $_J_V&quot;</span> &gt;&amp;<span class="nv">$_J_FD</span>;;
				*<span class="s2">&quot;\\&quot;</span><span class="o">)</span> ;;
				*<span class="o">)</span> <span class="nv">_J_V</span><span class="o">=</span><span class="s2">&quot;$_J_V$_J_C&quot;</span>;;
			<span class="k">esac</span>;;

	<span class="k">esac</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Print an error message and GTFO.  The message is the concatenation
of all the arguments to this function.</p>

</td><td class=code><div class=highlight><pre>
_json_die<span class="o">()</span> <span class="o">{</span>
	<span class="nb">echo</span> <span class="s2">&quot;json.sh: $*&quot;</span> &gt;&amp;2
	<span class="nb">exit </span>1
<span class="o">}</span>


</pre></div></td></tr><tr><td class=docs>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
